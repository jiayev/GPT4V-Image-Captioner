import { f as fade } from './Button-ab11cb83.js';
import { B as BlockTitle } from './BlockTitle-05ec971b.js';
import { C as Check } from './Check-f7edb5d9.js';
import { C as Copy } from './Copy-a69620a8.js';
import './Index-a77cc637.js';

const Textbox_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/js/textbox/shared/Textbox.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent,
	action_destroyer,
	add_render_callback,
	append,
	attr,
	binding_callbacks,
	bubble,
	check_outros,
	create_component,
	create_in_transition,
	destroy_component,
	detach,
	element,
	empty,
	group_outros,
	init,
	insert,
	is_function,
	listen,
	mount_component,
	noop,
	run_all,
	safe_not_equal,
	set_data,
	set_input_value,
	space,
	text,
	toggle_class,
	transition_in,
	transition_out
} = window.__gradio__svelte__internal;
const { beforeUpdate, afterUpdate, createEventDispatcher, tick } = window.__gradio__svelte__internal;
function create_default_slot(ctx) {
	let t;

	return {
		c() {
			t = text(/*label*/ ctx[3]);
		},
		m(target, anchor) {
			insert(target, t, anchor);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*label*/ 8) set_data(t, /*label*/ ctx[3]);
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}
		}
	};
}

// (198:1) {:else}
function create_else_block(ctx) {
	let t;
	let textarea;
	let textarea_dir_value;
	let textarea_style_value;
	let text_area_resize_action;
	let current;
	let mounted;
	let dispose;
	let if_block = /*show_label*/ ctx[6] && /*show_copy_button*/ ctx[10] && create_if_block_4(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			t = space();
			textarea = element("textarea");
			attr(textarea, "data-testid", "textbox");
			attr(textarea, "class", "scroll-hide svelte-1f354aw");
			attr(textarea, "dir", textarea_dir_value = /*rtl*/ ctx[11] ? "rtl" : "ltr");
			attr(textarea, "placeholder", /*placeholder*/ ctx[2]);
			attr(textarea, "rows", /*lines*/ ctx[1]);
			textarea.disabled = /*disabled*/ ctx[5];
			textarea.autofocus = /*autofocus*/ ctx[12];

			attr(textarea, "style", textarea_style_value = /*text_align*/ ctx[13]
			? "text-align: " + /*text_align*/ ctx[13]
			: "");
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, t, anchor);
			insert(target, textarea, anchor);
			set_input_value(textarea, /*value*/ ctx[0]);
			/*textarea_binding*/ ctx[38](textarea);
			current = true;
			if (/*autofocus*/ ctx[12]) textarea.focus();

			if (!mounted) {
				dispose = [
					action_destroyer(text_area_resize_action = /*text_area_resize*/ ctx[20].call(null, textarea, /*value*/ ctx[0])),
					listen(textarea, "input", /*textarea_input_handler*/ ctx[37]),
					listen(textarea, "keypress", /*handle_keypress*/ ctx[18]),
					listen(textarea, "blur", /*blur_handler_3*/ ctx[29]),
					listen(textarea, "select", /*handle_select*/ ctx[17]),
					listen(textarea, "focus", /*focus_handler_3*/ ctx[30]),
					listen(textarea, "scroll", /*handle_scroll*/ ctx[19])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*show_label*/ ctx[6] && /*show_copy_button*/ ctx[10]) {
				if (if_block) {
					if_block.p(ctx, dirty);

					if (dirty[0] & /*show_label, show_copy_button*/ 1088) {
						transition_in(if_block, 1);
					}
				} else {
					if_block = create_if_block_4(ctx);
					if_block.c();
					transition_in(if_block, 1);
					if_block.m(t.parentNode, t);
				}
			} else if (if_block) {
				group_outros();

				transition_out(if_block, 1, 1, () => {
					if_block = null;
				});

				check_outros();
			}

			if (!current || dirty[0] & /*rtl*/ 2048 && textarea_dir_value !== (textarea_dir_value = /*rtl*/ ctx[11] ? "rtl" : "ltr")) {
				attr(textarea, "dir", textarea_dir_value);
			}

			if (!current || dirty[0] & /*placeholder*/ 4) {
				attr(textarea, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (!current || dirty[0] & /*lines*/ 2) {
				attr(textarea, "rows", /*lines*/ ctx[1]);
			}

			if (!current || dirty[0] & /*disabled*/ 32) {
				textarea.disabled = /*disabled*/ ctx[5];
			}

			if (!current || dirty[0] & /*autofocus*/ 4096) {
				textarea.autofocus = /*autofocus*/ ctx[12];
			}

			if (!current || dirty[0] & /*text_align*/ 8192 && textarea_style_value !== (textarea_style_value = /*text_align*/ ctx[13]
			? "text-align: " + /*text_align*/ ctx[13]
			: "")) {
				attr(textarea, "style", textarea_style_value);
			}

			if (text_area_resize_action && is_function(text_area_resize_action.update) && dirty[0] & /*value*/ 1) text_area_resize_action.update.call(null, /*value*/ ctx[0]);

			if (dirty[0] & /*value*/ 1) {
				set_input_value(textarea, /*value*/ ctx[0]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t);
				detach(textarea);
			}

			if (if_block) if_block.d(detaching);
			/*textarea_binding*/ ctx[38](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (147:1) {#if lines === 1 && max_lines === 1}
function create_if_block(ctx) {
	let if_block_anchor;

	function select_block_type_1(ctx, dirty) {
		if (/*type*/ ctx[9] === "text") return create_if_block_1;
		if (/*type*/ ctx[9] === "password") return create_if_block_2;
		if (/*type*/ ctx[9] === "email") return create_if_block_3;
	}

	let current_block_type = select_block_type_1(ctx);
	let if_block = current_block_type && current_block_type(ctx);

	return {
		c() {
			if (if_block) if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
		},
		p(ctx, dirty) {
			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if (if_block) if_block.d(1);
				if_block = current_block_type && current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if (if_block) {
				if_block.d(detaching);
			}
		}
	};
}

// (199:2) {#if show_label && show_copy_button}
function create_if_block_4(ctx) {
	let current_block_type_index;
	let if_block;
	let if_block_anchor;
	let current;
	const if_block_creators = [create_if_block_5, create_else_block_1];
	const if_blocks = [];

	function select_block_type_2(ctx, dirty) {
		if (/*copied*/ ctx[15]) return 0;
		return 1;
	}

	current_block_type_index = select_block_type_2(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if_block.c();
			if_block_anchor = empty();
		},
		m(target, anchor) {
			if_blocks[current_block_type_index].m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;
		},
		p(ctx, dirty) {
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type_2(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(if_block_anchor.parentNode, if_block_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(if_block_anchor);
			}

			if_blocks[current_block_type_index].d(detaching);
		}
	};
}

// (206:3) {:else}
function create_else_block_1(ctx) {
	let button;
	let copy;
	let current;
	let mounted;
	let dispose;
	copy = new Copy({});

	return {
		c() {
			button = element("button");
			create_component(copy.$$.fragment);
			attr(button, "aria-label", "Copy");
			attr(button, "aria-roledescription", "Copy text");
			attr(button, "class", "svelte-1f354aw");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			mount_component(copy, button, null);
			current = true;

			if (!mounted) {
				dispose = listen(button, "click", /*handle_copy*/ ctx[16]);
				mounted = true;
			}
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(copy.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(copy.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			destroy_component(copy);
			mounted = false;
			dispose();
		}
	};
}

// (200:3) {#if copied}
function create_if_block_5(ctx) {
	let button;
	let check;
	let button_intro;
	let current;
	check = new Check({});

	return {
		c() {
			button = element("button");
			create_component(check.$$.fragment);
			attr(button, "aria-label", "Copied");
			attr(button, "aria-roledescription", "Text copied");
			attr(button, "class", "svelte-1f354aw");
		},
		m(target, anchor) {
			insert(target, button, anchor);
			mount_component(check, button, null);
			current = true;
		},
		p: noop,
		i(local) {
			if (current) return;
			transition_in(check.$$.fragment, local);

			if (local) {
				if (!button_intro) {
					add_render_callback(() => {
						button_intro = create_in_transition(button, fade, { duration: 300 });
						button_intro.start();
					});
				}
			}

			current = true;
		},
		o(local) {
			transition_out(check.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(button);
			}

			destroy_component(check);
		}
	};
}

// (181:29) 
function create_if_block_3(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "data-testid", "textbox");
			attr(input, "type", "email");
			attr(input, "class", "scroll-hide svelte-1f354aw");
			attr(input, "placeholder", /*placeholder*/ ctx[2]);
			input.disabled = /*disabled*/ ctx[5];
			input.autofocus = /*autofocus*/ ctx[12];
			attr(input, "autocomplete", "email");
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*value*/ ctx[0]);
			/*input_binding_2*/ ctx[36](input);
			if (/*autofocus*/ ctx[12]) input.focus();

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler_2*/ ctx[35]),
					listen(input, "keypress", /*handle_keypress*/ ctx[18]),
					listen(input, "blur", /*blur_handler_2*/ ctx[27]),
					listen(input, "select", /*handle_select*/ ctx[17]),
					listen(input, "focus", /*focus_handler_2*/ ctx[28])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 4) {
				attr(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 32) {
				input.disabled = /*disabled*/ ctx[5];
			}

			if (dirty[0] & /*autofocus*/ 4096) {
				input.autofocus = /*autofocus*/ ctx[12];
			}

			if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(input);
			}

			/*input_binding_2*/ ctx[36](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (165:32) 
function create_if_block_2(ctx) {
	let input;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "data-testid", "password");
			attr(input, "type", "password");
			attr(input, "class", "scroll-hide svelte-1f354aw");
			attr(input, "placeholder", /*placeholder*/ ctx[2]);
			input.disabled = /*disabled*/ ctx[5];
			input.autofocus = /*autofocus*/ ctx[12];
			attr(input, "autocomplete", "");
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*value*/ ctx[0]);
			/*input_binding_1*/ ctx[34](input);
			if (/*autofocus*/ ctx[12]) input.focus();

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler_1*/ ctx[33]),
					listen(input, "keypress", /*handle_keypress*/ ctx[18]),
					listen(input, "blur", /*blur_handler_1*/ ctx[25]),
					listen(input, "select", /*handle_select*/ ctx[17]),
					listen(input, "focus", /*focus_handler_1*/ ctx[26])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*placeholder*/ 4) {
				attr(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 32) {
				input.disabled = /*disabled*/ ctx[5];
			}

			if (dirty[0] & /*autofocus*/ 4096) {
				input.autofocus = /*autofocus*/ ctx[12];
			}

			if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(input);
			}

			/*input_binding_1*/ ctx[34](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (148:2) {#if type === "text"}
function create_if_block_1(ctx) {
	let input;
	let input_dir_value;
	let input_style_value;
	let mounted;
	let dispose;

	return {
		c() {
			input = element("input");
			attr(input, "data-testid", "textbox");
			attr(input, "type", "text");
			attr(input, "class", "scroll-hide svelte-1f354aw");
			attr(input, "dir", input_dir_value = /*rtl*/ ctx[11] ? "rtl" : "ltr");
			attr(input, "placeholder", /*placeholder*/ ctx[2]);
			input.disabled = /*disabled*/ ctx[5];
			input.autofocus = /*autofocus*/ ctx[12];

			attr(input, "style", input_style_value = /*text_align*/ ctx[13]
			? "text-align: " + /*text_align*/ ctx[13]
			: "");
		},
		m(target, anchor) {
			insert(target, input, anchor);
			set_input_value(input, /*value*/ ctx[0]);
			/*input_binding*/ ctx[32](input);
			if (/*autofocus*/ ctx[12]) input.focus();

			if (!mounted) {
				dispose = [
					listen(input, "input", /*input_input_handler*/ ctx[31]),
					listen(input, "keypress", /*handle_keypress*/ ctx[18]),
					listen(input, "blur", /*blur_handler*/ ctx[23]),
					listen(input, "select", /*handle_select*/ ctx[17]),
					listen(input, "focus", /*focus_handler*/ ctx[24])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (dirty[0] & /*rtl*/ 2048 && input_dir_value !== (input_dir_value = /*rtl*/ ctx[11] ? "rtl" : "ltr")) {
				attr(input, "dir", input_dir_value);
			}

			if (dirty[0] & /*placeholder*/ 4) {
				attr(input, "placeholder", /*placeholder*/ ctx[2]);
			}

			if (dirty[0] & /*disabled*/ 32) {
				input.disabled = /*disabled*/ ctx[5];
			}

			if (dirty[0] & /*autofocus*/ 4096) {
				input.autofocus = /*autofocus*/ ctx[12];
			}

			if (dirty[0] & /*text_align*/ 8192 && input_style_value !== (input_style_value = /*text_align*/ ctx[13]
			? "text-align: " + /*text_align*/ ctx[13]
			: "")) {
				attr(input, "style", input_style_value);
			}

			if (dirty[0] & /*value*/ 1 && input.value !== /*value*/ ctx[0]) {
				set_input_value(input, /*value*/ ctx[0]);
			}
		},
		d(detaching) {
			if (detaching) {
				detach(input);
			}

			/*input_binding*/ ctx[32](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

function create_fragment(ctx) {
	let label_1;
	let blocktitle;
	let t;
	let current_block_type_index;
	let if_block;
	let current;

	blocktitle = new BlockTitle({
			props: {
				show_label: /*show_label*/ ctx[6],
				info: /*info*/ ctx[4],
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*lines*/ ctx[1] === 1 && /*max_lines*/ ctx[8] === 1) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			label_1 = element("label");
			create_component(blocktitle.$$.fragment);
			t = space();
			if_block.c();
			attr(label_1, "class", "svelte-1f354aw");
			toggle_class(label_1, "container", /*container*/ ctx[7]);
		},
		m(target, anchor) {
			insert(target, label_1, anchor);
			mount_component(blocktitle, label_1, null);
			append(label_1, t);
			if_blocks[current_block_type_index].m(label_1, null);
			current = true;
		},
		p(ctx, dirty) {
			const blocktitle_changes = {};
			if (dirty[0] & /*show_label*/ 64) blocktitle_changes.show_label = /*show_label*/ ctx[6];
			if (dirty[0] & /*info*/ 16) blocktitle_changes.info = /*info*/ ctx[4];

			if (dirty[0] & /*label*/ 8 | dirty[1] & /*$$scope*/ 131072) {
				blocktitle_changes.$$scope = { dirty, ctx };
			}

			blocktitle.$set(blocktitle_changes);
			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block = if_blocks[current_block_type_index];

				if (!if_block) {
					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block.c();
				} else {
					if_block.p(ctx, dirty);
				}

				transition_in(if_block, 1);
				if_block.m(label_1, null);
			}

			if (!current || dirty[0] & /*container*/ 128) {
				toggle_class(label_1, "container", /*container*/ ctx[7]);
			}
		},
		i(local) {
			if (current) return;
			transition_in(blocktitle.$$.fragment, local);
			transition_in(if_block);
			current = true;
		},
		o(local) {
			transition_out(blocktitle.$$.fragment, local);
			transition_out(if_block);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(label_1);
			}

			destroy_component(blocktitle);
			if_blocks[current_block_type_index].d();
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { value = "" } = $$props;
	let { value_is_output = false } = $$props;
	let { lines = 1 } = $$props;
	let { placeholder = "Type here..." } = $$props;
	let { label } = $$props;
	let { info = undefined } = $$props;
	let { disabled = false } = $$props;
	let { show_label = true } = $$props;
	let { container = true } = $$props;
	let { max_lines } = $$props;
	let { type = "text" } = $$props;
	let { show_copy_button = false } = $$props;
	let { rtl = false } = $$props;
	let { autofocus = false } = $$props;
	let { text_align = undefined } = $$props;
	let { autoscroll = true } = $$props;
	let el;
	let copied = false;
	let timer;
	let can_scroll;
	let previous_scroll_top = 0;
	let user_has_scrolled_up = false;
	const dispatch = createEventDispatcher();

	beforeUpdate(() => {
		can_scroll = el && el.offsetHeight + el.scrollTop > el.scrollHeight - 100;
	});

	const scroll = () => {
		if (can_scroll && autoscroll && !user_has_scrolled_up) {
			el.scrollTo(0, el.scrollHeight);
		}
	};

	function handle_change() {
		dispatch("change", value);

		if (!value_is_output) {
			dispatch("input");
		}
	}

	afterUpdate(() => {
		if (autofocus) {
			el.focus();
		}

		if (can_scroll && autoscroll) {
			scroll();
		}

		$$invalidate(21, value_is_output = false);
	});

	async function handle_copy() {
		if ("clipboard" in navigator) {
			await navigator.clipboard.writeText(value);
			copy_feedback();
		}
	}

	function copy_feedback() {
		$$invalidate(15, copied = true);
		if (timer) clearTimeout(timer);

		timer = setTimeout(
			() => {
				$$invalidate(15, copied = false);
			},
			1000
		);
	}

	function handle_select(event) {
		const target = event.target;
		const text = target.value;
		const index = [target.selectionStart, target.selectionEnd];
		dispatch("select", { value: text.substring(...index), index });
	}

	async function handle_keypress(e) {
		await tick();

		if (e.key === "Enter" && e.shiftKey && lines > 1) {
			e.preventDefault();
			dispatch("submit");
		} else if (e.key === "Enter" && !e.shiftKey && lines === 1 && max_lines >= 1) {
			e.preventDefault();
			dispatch("submit");
		}
	}

	function handle_scroll(event) {
		const target = event.target;
		const current_scroll_top = target.scrollTop;

		if (current_scroll_top < previous_scroll_top) {
			user_has_scrolled_up = true;
		}

		previous_scroll_top = current_scroll_top;
		const max_scroll_top = target.scrollHeight - target.clientHeight;
		const user_has_scrolled_to_bottom = current_scroll_top >= max_scroll_top;

		if (user_has_scrolled_to_bottom) {
			user_has_scrolled_up = false;
		}
	}

	async function resize(event) {
		await tick();
		if (lines === max_lines) return;

		let max = max_lines === undefined
		? false
		: max_lines === undefined ? 21 * 11 : 21 * (max_lines + 1); // default

		let min = 21 * (lines + 1);
		const target = event.target;
		target.style.height = "1px";
		let scroll_height;

		if (max && target.scrollHeight > max) {
			scroll_height = max;
		} else if (target.scrollHeight < min) {
			scroll_height = min;
		} else {
			scroll_height = target.scrollHeight;
		}

		target.style.height = `${scroll_height}px`;
	}

	function text_area_resize(_el, _value) {
		if (lines === max_lines) return;
		_el.style.overflowY = "scroll";
		_el.addEventListener("input", resize);
		if (!_value.trim()) return;
		resize({ target: _el });

		return {
			destroy: () => _el.removeEventListener("input", resize)
		};
	}

	function blur_handler(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler_1(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler_2(event) {
		bubble.call(this, $$self, event);
	}

	function blur_handler_3(event) {
		bubble.call(this, $$self, event);
	}

	function focus_handler_3(event) {
		bubble.call(this, $$self, event);
	}

	function input_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(14, el);
		});
	}

	function input_input_handler_1() {
		value = this.value;
		$$invalidate(0, value);
	}

	function input_binding_1($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(14, el);
		});
	}

	function input_input_handler_2() {
		value = this.value;
		$$invalidate(0, value);
	}

	function input_binding_2($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(14, el);
		});
	}

	function textarea_input_handler() {
		value = this.value;
		$$invalidate(0, value);
	}

	function textarea_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			el = $$value;
			$$invalidate(14, el);
		});
	}

	$$self.$$set = $$props => {
		if ('value' in $$props) $$invalidate(0, value = $$props.value);
		if ('value_is_output' in $$props) $$invalidate(21, value_is_output = $$props.value_is_output);
		if ('lines' in $$props) $$invalidate(1, lines = $$props.lines);
		if ('placeholder' in $$props) $$invalidate(2, placeholder = $$props.placeholder);
		if ('label' in $$props) $$invalidate(3, label = $$props.label);
		if ('info' in $$props) $$invalidate(4, info = $$props.info);
		if ('disabled' in $$props) $$invalidate(5, disabled = $$props.disabled);
		if ('show_label' in $$props) $$invalidate(6, show_label = $$props.show_label);
		if ('container' in $$props) $$invalidate(7, container = $$props.container);
		if ('max_lines' in $$props) $$invalidate(8, max_lines = $$props.max_lines);
		if ('type' in $$props) $$invalidate(9, type = $$props.type);
		if ('show_copy_button' in $$props) $$invalidate(10, show_copy_button = $$props.show_copy_button);
		if ('rtl' in $$props) $$invalidate(11, rtl = $$props.rtl);
		if ('autofocus' in $$props) $$invalidate(12, autofocus = $$props.autofocus);
		if ('text_align' in $$props) $$invalidate(13, text_align = $$props.text_align);
		if ('autoscroll' in $$props) $$invalidate(22, autoscroll = $$props.autoscroll);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*value*/ 1) {
			if (value === null) $$invalidate(0, value = "");
		}

		if ($$self.$$.dirty[0] & /*value, el, lines, max_lines*/ 16643) {
			(el && lines !== max_lines && resize({ target: el }));
		}

		if ($$self.$$.dirty[0] & /*value*/ 1) {
			(handle_change());
		}
	};

	return [
		value,
		lines,
		placeholder,
		label,
		info,
		disabled,
		show_label,
		container,
		max_lines,
		type,
		show_copy_button,
		rtl,
		autofocus,
		text_align,
		el,
		copied,
		handle_copy,
		handle_select,
		handle_keypress,
		handle_scroll,
		text_area_resize,
		value_is_output,
		autoscroll,
		blur_handler,
		focus_handler,
		blur_handler_1,
		focus_handler_1,
		blur_handler_2,
		focus_handler_2,
		blur_handler_3,
		focus_handler_3,
		input_input_handler,
		input_binding,
		input_input_handler_1,
		input_binding_1,
		input_input_handler_2,
		input_binding_2,
		textarea_input_handler,
		textarea_binding
	];
}

class Textbox extends SvelteComponent {
	constructor(options) {
		super();

		init(
			this,
			options,
			instance,
			create_fragment,
			safe_not_equal,
			{
				value: 0,
				value_is_output: 21,
				lines: 1,
				placeholder: 2,
				label: 3,
				info: 4,
				disabled: 5,
				show_label: 6,
				container: 7,
				max_lines: 8,
				type: 9,
				show_copy_button: 10,
				rtl: 11,
				autofocus: 12,
				text_align: 13,
				autoscroll: 22
			},
			null,
			[-1, -1]
		);
	}
}

export { Textbox as T };
//# sourceMappingURL=Textbox-8d1e9b1f.js.map
